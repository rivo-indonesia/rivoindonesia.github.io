<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D World Ultra Realistic Textures</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; touch-action: none; font-family: sans-serif; }
        #ui { position: absolute; top: 20px; left: 20px; color: white; z-index: 10; pointer-events: none; }
        .box { background: rgba(0,0,0,0.4); padding: 15px; border-radius: 12px; backdrop-filter: blur(15px); border: 1px solid rgba(255,255,255,0.1); }
        #sprint-btn { 
            position: absolute; bottom: 40px; right: 40px; 
            width: 80px; height: 80px; background: rgba(255,255,255,0.2); 
            border: 2px solid white; border-radius: 50%; color: white; font-weight: bold;
            display: flex; align-items: center; justify-content: center; z-index: 30;
            pointer-events: auto;
        }
        #joystick-zone { position: absolute; bottom: 30px; left: 30px; width: 120px; height: 120px; z-index: 20; }
    </style>
</head>
<body>

    <div id="ui">
        <div class="box">
            <div id="time-status" style="letter-spacing: 2px; font-weight: bold;">GRAPHICS: ULTRA</div>
            <div id="timer" style="font-size: 24px; color: #00e5ff;">05:00</div>
        </div>
    </div>

    <div id="sprint-btn">RUN</div>
    <div id="joystick-zone"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>

    <script>
        let scene, camera, renderer, mainLight, sunDisc, moonDisc;
        let moveForward = 0, moveSide = 0, yaw = 0, pitch = 0, isSprinting = false;
        let collidableObjects = [];
        let worldTime = 0;
        const cycleDuration = 600;

        const loader = new THREE.TextureLoader();
        
        // TEKSTUR HD REALISTIS
        const textures = {
            grass: loader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg'),
            bark: loader.load('https://threejs.org/examples/textures/floors/FloorsCheckerboard_S_Diffuse.jpg'), // Tekstur kasar untuk pohon
            stone: loader.load('https://threejs.org/examples/textures/brick_diffuse.jpg') // Tekstur batu untuk gua
        };

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 2, 80);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            // AKTIFKAN ENGINE GRAFIK TERBAIK
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.15));
            mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.set(2048, 2048);
            scene.add(mainLight);

            sunDisc = new THREE.Mesh(new THREE.SphereGeometry(12, 32, 32), new THREE.MeshBasicMaterial({color: 0xffffff}));
            moonDisc = new THREE.Mesh(new THREE.SphereGeometry(8, 32, 32), new THREE.MeshBasicMaterial({color: 0xcccccc}));
            scene.add(sunDisc, moonDisc);

            createWorld();
            setupControls();
            animate();
        }

        function createWorld() {
            // LANTAI RUMPUT REALISTIS
            textures.grass.wrapS = textures.grass.wrapT = THREE.RepeatWrapping;
            textures.grass.repeat.set(150, 150);
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(2000, 2000),
                new THREE.MeshStandardMaterial({ map: textures.grass, roughness: 0.8 })
            );
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // POHON REALISTIS
            for (let i = 0; i < 45; i++) {
                let tx = (Math.random() - 0.5) * 400;
                let tz = (Math.random() - 0.5) * 400;
                if (Math.sqrt(tx*tx + (tz-80)*(tz-80)) < 25) continue;

                // Batang
                const trunk = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.6, 0.9, 8, 12),
                    new THREE.MeshStandardMaterial({ color: 0x4b3621, roughness: 0.9 })
                );
                trunk.position.set(tx, 4, tz);
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                scene.add(trunk);
                collidableObjects.push(trunk);

                // Daun Tidak Bulat (Dodecahedron Berlapis)
                for(let j=0; j<3; j++) {
                    const leaves = new THREE.Mesh(
                        new THREE.DodecahedronGeometry(4 - j),
                        new THREE.MeshStandardMaterial({ color: 0x1a4a1a, roughness: 0.7 })
                    );
                    leaves.position.set(tx, 8 + (j*2), tz);
                    leaves.rotation.y = Math.random() * Math.PI;
                    leaves.castShadow = true;
                    scene.add(leaves);
                }
            }

            // GUA (GOAH) DENGAN TEKSTUR BATU
            const cavePos = { x: 60, z: -60 };
            textures.stone.wrapS = textures.stone.wrapT = THREE.RepeatWrapping;
            const stoneMat = new THREE.MeshStandardMaterial({ map: textures.stone, color: 0x666666 });
            
            for(let i=0; i<15; i++) {
                const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(7), stoneMat);
                rock.position.set(cavePos.x + Math.cos(i)*10, 4, cavePos.z + Math.sin(i)*10);
                rock.rotation.set(Math.random(), Math.random(), Math.random());
                rock.castShadow = true;
                rock.receiveShadow = true;
                scene.add(rock);
                collidableObjects.push(rock);
            }
            
            // CAHAYA GUA
            const caveLight = new THREE.PointLight(0xff6600, 4, 40);
            caveLight.position.set(cavePos.x, 7, cavePos.z);
            scene.add(caveLight);
        }

        function updateSky() {
            worldTime += 0.012;
            let angle = (worldTime % cycleDuration) / cycleDuration * Math.PI * 2;
            let sunY = Math.sin(angle) * 500;
            let sunX = Math.cos(angle) * 500;

            sunDisc.position.set(sunX, sunY, -250);
            moonDisc.position.set(-sunX, -sunY, -250);

            let skyCol = new THREE.Color();
            if (sunY > 40) {
                skyCol.setHSL(0.58, 0.5, 0.5);
                mainLight.intensity = 1.3;
            } else if (sunY > -30) {
                skyCol.lerpColors(new THREE.Color(0xff4400), new THREE.Color(0x87CEEB), (sunY + 30) / 70);
                mainLight.intensity = 0.9;
            } else {
                skyCol.setHSL(0.65, 0.5, 0.03);
                mainLight.intensity = 0.4;
                mainLight.color.setHex(0x99aaff);
            }
            scene.background = skyCol;
            scene.fog = new THREE.FogExp2(skyCol, 0.006);
            mainLight.position.copy(sunY > 0 ? sunDisc.position : moonDisc.position);
            
            let mins = Math.floor((cycleDuration - (worldTime % cycleDuration)) / 60);
            let secs = Math.floor((cycleDuration - (worldTime % cycleDuration)) % 60);
            document.getElementById('timer').innerText = `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function setupControls() {
            nipplejs.create({
                zone: document.getElementById('joystick-zone'),
                mode: 'static', position: { left: '80px', bottom: '80px' }, color: 'white'
            }).on('move', (e, data) => {
                moveForward = Math.sin(data.angle.radian) * (data.distance / 50);
                moveSide = Math.cos(data.angle.radian) * (data.distance / 50);
            }).on('end', () => { moveForward = 0; moveSide = 0; });

            document.getElementById('sprint-btn').addEventListener('touchstart', (e) => { e.preventDefault(); isSprinting = true; });
            document.getElementById('sprint-btn').addEventListener('touchend', () => isSprinting = false);

            let lastX, lastY;
            window.addEventListener('touchstart', e => {
                if(e.touches[0].clientX > window.innerWidth / 2) {
                    lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
                }
            });
            window.addEventListener('touchmove', e => {
                const touch = Array.from(e.touches).find(t => t.clientX > window.innerWidth / 2);
                if(touch && lastX !== undefined) {
                    yaw -= (touch.clientX - lastX) * 0.007;
                    pitch = Math.max(-1.4, Math.min(1.4, pitch - (touch.clientY - lastY) * 0.007));
                    lastX = touch.clientX; lastY = touch.clientY;
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            updateSky();

            camera.rotation.order = "YXZ";
            camera.rotation.y = yaw; camera.rotation.x = pitch;

            const speed = isSprinting ? 0.6 : 0.25;
            let dirZ = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
            let dirX = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion);
            dirZ.y = 0; dirX.y = 0;

            let nextPos = camera.position.clone();
            nextPos.addScaledVector(dirZ, moveForward * speed);
            nextPos.addScaledVector(dirX, moveSide * speed);

            let canMove = true;
            for(let obj of collidableObjects) {
                if(new THREE.Vector2(nextPos.x - obj.position.x, nextPos.z - obj.position.z).length() < 3.2) {
                    canMove = false; break;
                }
            }
            if(canMove) camera.position.copy(nextPos);
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>